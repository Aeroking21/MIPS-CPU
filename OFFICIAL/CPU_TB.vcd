$date
	Thu Dec 16 23:19:08 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU_tb $end
$var wire 32 ! register_v0 [31:0] $end
$var wire 32 " instr_readdata [31:0] $end
$var wire 32 # instr_address [31:0] $end
$var wire 32 $ data_writedata [31:0] $end
$var wire 1 % data_write $end
$var wire 32 & data_readdata [31:0] $end
$var wire 1 ' data_read $end
$var wire 32 ( data_address [31:0] $end
$var wire 1 ) active $end
$var reg 1 * clk $end
$var reg 1 + clock_enable $end
$var reg 1 , reset $end
$scope module CPU $end
$var wire 1 * clk $end
$var wire 1 + clock_enable $end
$var wire 32 - register_v0 [31:0] $end
$var wire 1 , reset $end
$var wire 1 . write_enable $end
$var wire 26 / target [25:0] $end
$var wire 3 0 subtype [2:0] $end
$var wire 33 1 sign_ext_offset [32:0] $end
$var wire 33 2 sign_ext_address [32:0] $end
$var wire 1 3 shift_op2 $end
$var wire 1 4 shift $end
$var wire 5 5 shamt [4:0] $end
$var wire 6 6 reg_addrw [5:0] $end
$var wire 6 7 reg_addr2 [5:0] $end
$var wire 6 8 reg_addr1 [5:0] $end
$var wire 32 9 out [31:0] $end
$var wire 32 : op_2 [31:0] $end
$var wire 32 ; op_1 [31:0] $end
$var wire 18 < offset [17:0] $end
$var wire 32 = instr_readdata [31:0] $end
$var wire 32 > instr_address_next [31:0] $end
$var wire 32 ? instr [31:0] $end
$var wire 2 @ funct_tail [1:0] $end
$var wire 6 A funct [5:0] $end
$var wire 32 B data_readdata [31:0] $end
$var wire 32 C data_address [31:0] $end
$var wire 32 D data [31:0] $end
$var wire 16 E astart [15:0] $end
$var wire 1 F R_type $end
$var wire 4 G PC_upper [3:0] $end
$var wire 3 H OP_tail [2:0] $end
$var wire 6 I OP [5:0] $end
$var wire 1 J MSB $end
$var wire 32 K LO [31:0] $end
$var wire 1 L J_type $end
$var wire 1 M I_type $end
$var wire 32 N HI [31:0] $end
$var reg 4 O ALU_code [3:0] $end
$var reg 32 P HI_reg [31:0] $end
$var reg 32 Q LO_reg [31:0] $end
$var reg 32 R PC_next [31:0] $end
$var reg 1 ) active $end
$var reg 33 S branch_to [32:0] $end
$var reg 1 ' data_read $end
$var reg 1 % data_write $end
$var reg 32 T data_writedata [31:0] $end
$var reg 32 U destination [31:0] $end
$var reg 32 V instr_address [31:0] $end
$var reg 1 W jump $end
$var reg 1 X jump_now $end
$var reg 32 Y jump_to [31:0] $end
$var reg 32 Z reg_write [31:0] $end
$var reg 1 [ reset_prev $end
$var reg 1 \ stall $end
$var reg 1 ] stall_prev $end
$scope module ALU $end
$var wire 4 ^ alu_control [3:0] $end
$var wire 32 _ op1 [31:0] $end
$var wire 32 ` op2 [31:0] $end
$var wire 32 a low [0:31] $end
$var wire 32 b high [0:31] $end
$var reg 64 c divmult_out [63:0] $end
$var reg 32 d out [0:31] $end
$upscope $end
$scope module ls $end
$var wire 6 e OP [5:0] $end
$var wire 16 f astart [15:0] $end
$var wire 1 * clk $end
$var wire 32 g data [31:0] $end
$var wire 32 h op_1 [31:0] $end
$var wire 32 i op_2 [31:0] $end
$var wire 1 \ stall $end
$var wire 1 j sign3 $end
$var wire 1 k sign2 $end
$var wire 1 l sign1 $end
$var wire 1 m sign0 $end
$var wire 32 n read_data [31:0] $end
$var wire 8 o op_2_b3 [7:0] $end
$var wire 8 p op_2_b2 [7:0] $end
$var wire 8 q op_2_b1 [7:0] $end
$var wire 8 r op_2_b0 [7:0] $end
$var wire 32 s data_address [31:0] $end
$var wire 2 t byte_enable [1:0] $end
$var wire 8 u byte3 [7:0] $end
$var wire 8 v byte2 [7:0] $end
$var wire 8 w byte1 [7:0] $end
$var wire 8 x byte0 [7:0] $end
$var wire 32 y address [31:0] $end
$var reg 32 z data_prev [31:0] $end
$var reg 32 { data_temp [31:0] $end
$upscope $end
$scope begin $unm_blk_41 $end
$var integer 32 | i [31:0] $end
$upscope $end
$upscope $end
$scope module MEM $end
$var wire 32 } addr [31:0] $end
$var wire 32 ~ instruction [31:0] $end
$upscope $end
$scope module ramx $end
$var wire 32 !" addr [31:0] $end
$var wire 32 "" data_in [31:0] $end
$var wire 1 ' data_read $end
$var wire 1 % data_write $end
$var wire 32 #" data_out [31:0] $end
$var wire 8 $" byte3_in [7:0] $end
$var wire 8 %" byte2_in [7:0] $end
$var wire 8 &" byte1_in [7:0] $end
$var wire 8 '" byte0_in [7:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx '"
bx &"
bx %"
bx $"
bx #"
bx ""
bx00 !"
bx ~
bx }
b0 |
bx {
bx z
bx y
bx x
bx w
bx v
bx u
bx t
bx00 s
bx r
bx q
bx p
bx o
bx n
xm
xl
xk
xj
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
b0xxx ^
x]
x\
x[
bx Z
bx Y
xX
xW
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
b0xxx O
bx N
xM
xL
bx K
xJ
bx I
bx H
bx G
xF
bx E
bx D
bx00 C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
b0xxxxx 8
b0xxxxx 7
b0xxxxx 6
bx 5
x4
x3
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 2
bx 1
bx 0
bx /
x.
bx -
x,
x+
0*
x)
bx00 (
x'
bx &
x%
bx $
bx #
bx "
bx !
$end
#1
b0 !
b0 -
1[
1)
0m
0l
0k
0j
b0 x
b0 w
b0 v
b0 u
b0 &
b0 B
b0 n
b0 #"
xW
b10111111110000000000000000000000 R
0%
0'
b100000 |
1,
1+
1*
#2
0*
#3
1.
1M
b0 r
b0 q
b0 Z
0W
0L
b0 9
b0 d
14
0F
b0 p
b0 o
b10000 6
b1 O
b1 ^
b10111111110000000000000000000100 S
b0 t
b0 (
b0 C
b0 s
b0 !"
0J
b1 H
b0 :
b0 `
b0 i
b0 @
03
b10110000010000000000000000000000 Y
b0 y
0\
b0 ;
b0 _
b0 h
b1001 I
b1001 e
b1 0
b0 8
b10000 7
b0 A
b100000000000000000000 /
b0 1
b0 <
b0 E
b0 f
b0 5
b100100000100000000000000000000 ?
b1011 G
b1000000100100 "
b1000000100100 =
b1000000100100 ~
b10111111110000000000000000000100 >
b10111111110000000000000000000000 2
b10111111110000000000000000000000 #
b10111111110000000000000000000000 V
b10111111110000000000000000000000 }
0m
0l
0k
0j
b0 x
b0 w
b0 v
b0 u
b0 &
b0 B
b0 n
b0 #"
0%
0'
b100000 |
0,
1*
#4
0*
#5
0.
0M
04
b0 o
1W
b0 9
b0 d
1F
b0 :
b0 `
b0 i
b0 H
b0 6
b0 Y
b1000 (
b1000 C
b1000 s
b1000 !"
b1000 O
b1000 ^
b0 I
b0 e
b0 0
b0 7
b1000 A
b1000 /
b100000 1
b100000 <
b1000 y
b1000 E
b1000 f
b1000 ?
b1000000000000000000000000000 "
b1000000000000000000000000000 =
b1000000000000000000000000000 ~
b10111111110000000000000000101000 S
0]
b10111111110000000000000000001000 >
b10111111110000000000000000000100 2
b10111111110000000000000000000100 #
b10111111110000000000000000000100 V
b10111111110000000000000000000100 }
0X
b10111111110000000000000000000100 U
0[
1*
#6
0*
#7
b1 Z
b1 o
b1 9
b1 d
b1 :
b1 `
b1 i
1.
1M
14
0F
b0 K
b0 a
b0 N
b0 b
b110 H
b10 6
b1 @
0W
b10111000000010000000000000000100 Y
b1 t
b0 (
b0 C
b0 s
b0 !"
b0 c
b110 O
b110 ^
b1110 I
b1110 e
b1 0
b10000 8
b10 7
b1 A
b10000000100000000000000001 /
b100 1
b100 <
b1 y
b1 E
b1 f
b111010000000100000000000000001 ?
b1000000000000001000111010 "
b1000000000000001000111010 =
b1000000000000001000111010 ~
b10111111110000000000000000010000 S
b10111111110000000000000000001100 >
b10111111110000000000000000001000 2
b10111111110000000000000000001000 #
b10111111110000000000000000001000 V
b10111111110000000000000000001000 }
1X
b0 U
1*
#8
0*
#9
x.
xM
xm
xl
xk
xj
bx x
bx w
bx v
bx u
xL
x4
bx r
bx q
bx p
bx o
bx Z
bx &
bx B
bx n
bx #"
xF
xJ
bx :
bx `
bx i
b0xxx O
b0xxx ^
bx 9
bx d
bx H
b0xxxxx 6
bx ;
bx _
bx h
bx @
x3
xW
bx t
bx00 (
bx00 C
bx00 s
bx00 !"
x%
x'
x\
bx I
bx e
bx 0
b0xxxxx 8
b0xxxxx 7
bx A
bx /
bx 1
bx <
bx y
bx E
bx f
bx 5
bx Y
bx ?
b0 G
bx "
bx =
bx ~
bx S
b100 >
b0 2
b0 #
b0 V
b0 }
0X
b10111111110000000000000000010000 U
b1 !
b1 -
1*
#10
0*
#11
bx G
0)
bx >
b0x0xxxxxxxx0000000000000000000x00 2
bx0xxxxxxxx0000000000000000000x00 #
bx0xxxxxxxx0000000000000000000x00 V
bx0xxxxxxxx0000000000000000000x00 }
xX
bx U
x]
1*
#12
0*
#13
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 2
bx #
bx V
bx }
1*
